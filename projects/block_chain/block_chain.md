### Reasoning Behind Decisions

The implementation uses two primary classes: `Block` and `BlockChain`. The `Block` class is designed to encapsulate all essential properties of a block, such as its index, previous hash, timestamp, data, and the hash calculated using `sha256`. This structure ensures each block is self-contained and immutable once created, maintaining the integrity of the blockchain. The `BlockChain` class manages the sequence of blocks, starting with a genesis block, and provides methods to add new blocks and validate the chain. Using a list to store the blocks allows easy sequential access and appending, which is suitable for a blockchain's linear structure. The `calc_hash` method ensures each block's hash is unique and based on its contents, making it crucial for verifying the integrity of the chain.

### Time and Space Efficiency

The time efficiency of this blockchain implementation primarily revolves around the `add_block` and `is_chain_valid` methods. Adding a block (`add_block`) operates in constant time \(O(1)\) since it involves accessing the latest block and appending a new block to the list. The `is_chain_valid` method, which checks the integrity of the entire chain, operates in linear time \(O(n)\), where \(n\) is the number of blocks in the chain, as it needs to iterate through all blocks to verify their hashes. The space efficiency is \(O(n)\) because each block is stored in a list, and the storage required grows linearly with the number of blocks. The hash calculation within each block involves fixed-size operations, maintaining constant space for each block regardless of the amount of data in the blockchain.
