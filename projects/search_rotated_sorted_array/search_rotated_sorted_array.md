### Reasoning Behind the Decisions

The algorithm employs a modified binary search to find the target in a rotated sorted array efficiently. The key insight is that even though the entire array is rotated, at least one half of the array (either left or right) is always sorted. By determining which half is sorted, we can decide whether the target lies within that half or the other half. This allows us to discard half of the search space in each iteration. We compare the middle element with the target and adjust our search range accordingly. If the left half is sorted and the target lies within this range, we narrow our search to the left half; otherwise, we search the right half, and vice versa. This method ensures that we maintain a logarithmic time complexity while accurately locating the target or concluding its absence.

### Time and Space Complexity

The time complexity of the algorithm is \( O(\log n) \). This is because the binary search method splits the search range in half with each iteration, reducing the number of elements to be checked by a factor of two each time. Consequently, the number of iterations required to converge to the solution is logarithmic in relation to the input size. The space complexity is \( O(1) \), as the algorithm uses a constant amount of space regardless of the input size. The variables used for start, end, and mid indices do not scale with the size of the input, ensuring that the space requirement remains minimal and constant. This makes the algorithm both time-efficient and space-efficient for searching in a rotated sorted array.
